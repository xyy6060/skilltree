树和二叉树
	树（tree）是由n(n >= 0)个节点的有限集。在任意一棵非空树：
	（1）有且仅有一个特定的被称为根（root）的节点
	（2）当n >1 ，其余的节点可分为m（m > 0）个互不相交的有限集 T1,T2,T3...Tm
			其中每个集合本身又是一棵树，并且称为根的子树
			
	树的节点包含一个数据元素及若干个指向其子树的分支（保存的“关系”）
	节点的度（degree）：节点拥有的子树数称为节点的度。
	度为0的节点称为叶子节点或终端节点
	度不为0的节点称为分支节点或非终端节点
	
	节点的层次（Level）：从根开始定义起，根为第一层，根的孩子节点为第二层...
	树中的最大层次称为树的高度或深度（Depth）
	
	
	二叉树（Binary Tree）是一种树形结构，它的特点是每个节点至多只有两颗子树
	（二叉树中不存在度大于2的节点），并且，二叉树的子树有左右之分，其次序不能任意颠倒
	
	二叉树的五种形态：
	（1）空树
	（2）只有一个节点（没有孩子节点）
	（3）只有一个左孩子
	（4）只有一个右孩子
	（4）有左右孩子
	
	二叉树的性质：
	（1）在二叉树的第i层至多有2^(i-1)个节点(i >= 1)
		证明：
			数学归纳法
				当i = 1, 1 = 2^(1-1)
				当i = 2, 1 = 2^(2-1)
				...
				2^(i-1)
				
	（2）深度为k的二叉树至多有(2^k)-1个节点(k >= 1)
		证明：
			设n 为这棵树的总结点
			k = 1    n = 1
			k = 2    n = 1+2
			k = 3    n = 1+2+4
			
			
			n = 1+2+4+8 +...2^(k-1)  =>(2^k)-1
			
	（3）对任意一棵二叉树T,如果其终端节点数为n0,度为2的节点节点数为n2
		则 n0 = n2+1
			
			证明：
				设N为一棵二叉树的总结点树，终端节点数为n0,度为2的节点节点数为n2
				度为1的节点节点数为n1
				
					N = n0+n1+n2   (1)
					
				设B为一棵二叉树的分支数
					从下往上看，每个节点（除了根节点）都对应一个向上的分支
					
					N = B+1  (2)
					
					从上往下看，一个节点如果有一个孩子，它就会有一个向下的分支
					如果有两个孩子，它就会有两个向下的分支	，如果没有个孩子，没有向下的分支
					
					B = n1+2*n2+0  (3)
					
					有(1)(2)(3)
					=>
					n1+2*n2+0 +1 = n0+n1+n2
					=>n2+1 = n0
					
	满二叉树：一棵深度为k且有2^k-1个节点的二叉树称为满二叉树
				在不改变层次（深度）的情况下，不能再添加节点
	
	完全二叉树：满足一下两个条件的二叉树
		（1）除去最后一层为一棵满二叉树
		（2）最后一层的节点的排列尽左边来（左边没有空隙）
		
	（4）如果对一棵有n个节点的完全二叉树从上至下，从左至右
		给每一个节点从1开始编号，那么如果一个节点的编号为i
		那么他的父节点（如果有）编号为：i/2
		它的左孩子（如果有）编号为：2*i
		它的右孩子（如果有）编号为：2*i+1
		
		证明：假设编号为i的节点，在第k层。
		那么第k层的第一个节点的编号为:2^(k-1)
		i这个节点在这一层前面有多少个节点：
			i-2^(k-1)
			
		i的孩子节点在k+1层
			它的左孩子（如果有）:2^(k)+2*(i-2^(k-1))  =>2i
			它的左孩子（如果有）:2i+1
			
		父节点的编号 ：i/2
		
		
	（5）具有n个节点的完全二叉树的深度  ：log2n向下取整+1	
	
		证明：
			假设深度为k
			
				2^(k-1)-1 < n  <= 2^k-1
				
				=>2^(k-1) <= n < 2^k
				
				
				
如何来保存二叉树的节点？
	（1）保存数据
	（2）数据与数据之间的关系
			一个节点i，它的父节点是谁，它的左右孩子是谁
		
		
（1）顺序存储
		用一组地址连续的空间去存储二叉树
			如何保存？数组
				如何表示节点与节点之间的关系
		“完全二叉树”有一个性质
			i  =>i/2
				...
				
		用数组来保存一棵完全二叉树
		typedef int TElemType;
		#define MAX 100
		
		TElemType SqBiTree[MAX];
		
		SqBiTree[1]  保存这颗树的根节点的数据
		SqBiTree[2]  保存编号为2的节点
		
		....
		SqBiTree[i]
		....
		
		SqBiTree[i]  =>SqBiTree[i/2]  父节点
					=>SqBiTree[2*i]   左孩子节点
					=>SqBiTree[2*i+1]   右孩子节点
		
					
		假如我这颗树不是完全二叉树？
			=》补全为一棵完全二叉树
			
（2）链式存储
			树的节点：
				数据域保存数据元素
				两个（至少）指针域，来保存它的左右孩子节点
				
			typedef int TElemType;	
			struct BiTNode
			{
				TElemType data;
				struct BiTNode *lchild,*rchild;//左右孩子节点的指针
			};
				
	创建一棵二叉树？
		一般都创建一棵二叉排序树

二叉排序树（Binary Sort Tree）：二叉查找树
	二叉排序树或者是一颗空树，或者具有以下性质的二叉树：
	（1）若它的左子树不为空，则左子树上所有节点的值均小于它的根节点的值
	（2）若它的右子树不为空，则右子树上所有节点的值均大于它的根节点的值
	（3）它的左右子树也分别为二叉排序树

二叉排序树的创建过程：实际上就是不断的把一个节点加入到一棵二叉排序树并且
				保持其排序性的过程。
					
			不断的重复二叉排序树的插入
			
二叉排序树的插入操作：
			（1）找插入位置
				新插入的节点一定是一个新添加的叶子结点，并且是查找不成功时
					查找路径上访问的最后一个节点的左孩子节点或右孩子节点
					
			（2）插入

树的遍历：
		如何按照某条搜索路径访问树中的每个节点，使得每个节点均被访问一次，而且仅被访问一次
		
		“访问” 的含义很广，可以对这个作任何的处理
		
		
		一般左孩子访问在右孩子访问之前
			剩下的就是根的访问次序
			
			=》 根  左   右   先序遍历
			=》 左   根  右    中序遍历
			=》 左   右   根    后序遍历
			
			如果按照先序遍历：
				（1）先访问根节点
				（2）在按照先序遍历的方法去访问根的左子树
				（3）在按照先序遍历的方法去访问根的右子树
			
		
		用形式化的语言来描述这种方法
			F(t)  =>F表示用先序遍历的方法，t表示的是一棵树
				
			F(t):
				if(t == NULL)
					return ;
				(1) print t->data
				(2) F(t->lchild)
				(3) F(t->rchild)
	
	如果按照中序遍历：
		（1）先按照中序遍历的方法去访问根的左子树
		（2）在访问根节点
		（3）在按照中序遍历的方法去访问根的右子树
		
	如果按照后序遍历：
		（1）先按照后序遍历的方法去访问根的左子树
		（2）在按照后序遍历的方法去访问根的右子树
		（3）在访问根节点

		
	作业：
		1.
		2.给你一棵树的遍历次序，画出这棵树
			已知：
				先 ：EBADCFHGIKJ
				中 ：ABCDEFGHIJK
				
				
		3.求一棵树的高度
		
		
平衡二叉树（Balanced Binary Tree）又称AVL树。
它或者是一棵空树，或者具有如下性质
	它的左子树或右子树都是平衡二叉树，且左子树与右子树的高度之差的绝对值不超过1
	
	若将二叉树上的节点的平衡因子定义为该节点的左子树的深度减去右子树的深度
	平衡二叉树上所有节点的平衡因子只可能为-1 0 1
	只要二叉树上有一个节点的平衡因子大于1，就不平衡
	
二叉排序树  =》平衡的二叉排序树
	操作？  是一颗不平衡的二叉树变成一颗平衡二叉树
	
	平衡操作
	
	平衡操作有4种情况

	（1）单向右旋平衡操作
			在不平衡节点的左子节点的左边新增加了一个节点  =》对不平衡节点作单向右旋平衡操作
			
			K2 =>不平衡节点
			
			x =>新加入的节点
			
			x->data < K2->lchild->data
			
	(2)单向左旋平衡操作
			在不平衡节点的右子节点的右边新增加了一个节点  =》对不平衡节点作单向左旋平衡操作
			
			K2 =>不平衡节点
			
			x =>新加入的节点
			
			x->data > K2->rchild->data
			
	(3)双向旋转
		先左后右
		在不平衡节点的左子节点的右边新增加一个节点
			=》先把不平衡节点的左子节点作单向左旋平衡处理
			=》然后在对不平衡节点作单向右旋平衡处理
			
			
		先右后左
		在不平衡节点的右子节点的左边新增加一个节点
			=》先把不平衡节点的右子节点作单向右旋平衡处理
			=》然后在对不平衡节点作单向左旋平衡处理	
				
作业：	
	求一棵二叉树的宽度