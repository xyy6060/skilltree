图：
	图（Graph）是一种非线性结构
	节点之间的关系是任意的，图中的任意两个数据元素之间都可能相关
	
图的形式化
	Graph = （V,R）
	
	其中  V = {Vi | 属于数据，i = 0,1,2,3,.....n-1 } 图中元素Vi（顶点Vertex）的集合
	
	R= {<Vi,Vj> |<Vi,Vj> 属于V，且 P(Vi,Vj)存在，P(Vi,Vj)表示Vi到Vj存在一条路径}
	是顶点关系的集合
	
	P(Vi,Vj)是Vi到Vj存在路径的一个判定条件
	

无向图：
	路径  =》边
	如果<Vi,Vj>存在，那么<Vj,Vi>就一定存在
	
有向图：
	路径  =》弧
	
网：
	若在图的关系<Vi,Vj>或<Vj,Vi>上附加一个值（权值w）
	w:弧或边上的权值，带有权的图称为网
	
顶点的度：
		顶点的边或弧的条数
	
图的物理存储结构：
	图要存储什么东西？
		顶点的集合  =》数据元素的集合
		关系的集合  =》顶点与顶点之间的路径
		
“数组表示法”
“邻接表”
“十字链表”
“邻接多重表”

邻接点：在无向图中，若存在一条边(Vi,Vj),称Vi,Vj互为邻接点

		在有向图中，若存在一条弧(Vi,Vj),Vi是该弧的起点，Vj是该弧的终点
		Vj是Vi的邻接点
		
1.“数组表示法” 又名为“邻接矩阵”
	
	用到两个数组来存储G
	一个一维数组来存储顶点的集合
	一个二维数组来存储G中顶点关系的集合
	
	用C来实现“邻接矩阵”
	#define MAX 100
	typedef char ElemType;
	
	struct Graph
	{
		ElemType V[MAX];//顶点的集合
		int A[MAX][MAX];//关系的集合 
		int vexnum;//图中的顶点个数
		int arcnum;//图中边或弧的个数
		//...
	};
	
2.邻接表
	数组+链表
	将图中每个顶点V和由V发出的弧或边构成的一个单链表
	邻接表是图的一种链式存储结构
	#define MAX 100
	typedef char ElemType;
	
	struct side
	{
		int w;//权值w）
		int stop;//终点元素的下标
		struct side*next;
	};
	
	struct node//顶点节点
	{
		ElemType v;//起点元素
		struct side*first;//指向第一条依附在该顶点弧/边的指针
	};
	
	
	struct node*list[MAX];
	
3.图的遍历
	图的遍历类似于树的遍历的推广，是按照某种某种规则（次序）访问图中的各个顶点
	一次且仅一次。
	
	对图的遍历通常有“深度优先搜索” 和“广度优先搜索”
	
	
	（1）深度优先搜索（DFS：depth first search）=》类似于树的先根遍历
	
	设初始时，图中的各个顶点未被访问，从某个顶点出发（设V0）,
	访问V0,然后再去搜索V0的邻接点Vi.若Vi未被访问，则按照同样的方法去访问
	在去搜索Vi的邻接点，（深度优先）..该顶点的邻接点全部访问完毕，则回溯到它的
	上一个顶点，然后在从此顶点以深度优先搜索的方式搜索下去...
	直到所有能访问的顶点全部访问完毕
	
	V ：v1,v2,v3
	
DFS:
	visit V
	
	if(V1未被访问)
	{
		visit V1
		DFS(g,V1);
	}
	if(V2未被访问)
	{
		visit V1
		DFS(g,V2);
	}
	if(V3未被访问)
	{
		visit V1
		DFS(g,V3);
	}
	
DFS(g,v)
{
	visit v
	for(取v的第一个邻接点l;邻接点存在;获取v的下一个邻接点给l)
	{
		if(l未被访问)
		{
			visit V1
			DFS(g,l);
		}
	}
	
}
	
		
	(2)广度优先搜索BFS ：Breadth First Search
		
		类似于树的层次遍历
	
	初始时，图中所有顶点均未被访问
	从图中某一个顶点出发（V0）访问，然后依次访问V0的邻接点（广度优先）
	然后，在从这些被访问完的邻接点出发，按照广度优先搜索去访问其他顶点...
	直到所有的顶点被访问完
	
算法：
	q = InitQueue();
	
	for(i = 0;i < g->vexnum;i++)
	{
		if(i未被访问)
		{
			visit i
			EnQueue(q,i);
			while(队列非空)
			{
				int j;
				DeQueue(q,&j);
				
				//让出队元素的未被访问邻接点入队
				for(取j的第一个邻接点l;邻接点存在;获取j的下一个邻接点给l)
				{
					if(l未被访问)
					{
						EnQueue(q,l);
					}
				}
			}
		}
	}
	
	DestroyQueue(q);
	
4.最短路径问题
	解决带权有向图中两个顶点之间的最短路径问题
	
	Dijkstra(迪杰斯特拉)算法和Floyd（弗洛伊德）算法
	都是基于比较 v0vi 与  v0vk+vkvi 的大小的基本算法
	Floyd（弗洛伊德）：使用三次循环计算出每个顶点到其他点的最短距离
	Dijkstra(迪杰斯特拉)：使用两次循环计算出一个顶点到其他点的最短距离
	
	
	Dijkstra(迪杰斯特拉) ：是解决网络中任意顶点（起点）到其他顶点（终点）的最短路径
	
	算法思路：如果点i到点j的最短路径经过k，
			则ij路径中，i到k的路径一定是i，k的最短路径
		
		按照路径长度递增次序产生从某源点到图中的其余每个顶点的最短路径
	
需要辅助向量：
（1）向量s[n]
		s[i] = 1;//源点v到i的最短路径求出来
		s[i] = 0;//源点v到i的最短路径没有求出来
		
		初始时s[v] = 1,其他的s[i] = 0
		
(2)向量dist[n]
	dist[i] =>存放的源点v到i的最短路径的距离（长度）
	
	dist[i] = <v,i>上的权w，若P(v,i)存在，v到i之间有一条直接路径
	dist[i] = 无穷大 若 P(v,i)不存在，v到i之间有没有直接路径
	
(3)向量path[n]

	path[i] 存放的是源点v到i的最短路径（v.....i）

	初始时path[i] = {v}; (表示从v出发)
	
	
step1:
	从源点到其他各个顶点的第一条最短路径  dist[u]
	
	dist[u] = min{dist[w] | w = 0,1,2,3,....n-1,且s[w] = 0}	
		表示在所有未求出的当前最短路径中找出一条最短的，其长度作为当前求出的最短路径
		
step2:
	对于所有的s[w] = 0 （表示v到w的最短路径是没有求出）
		if(dist[u] + <u,w> < dist[w])
		{
			更新dist[w] = dist[u] + <u,w>
		}
		
	goto step1...
		
		
		
		
		

	