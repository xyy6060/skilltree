引用：
	int a,b,c,d,......
	int sum
	
	=>
	定义一类或一组变量
	
数组

1.数组是什么？
	数组是一组具有相同类型的数据（变量）的集合
	
C语言中数组：
	一维数组
	二维数组
	三维数组
	...
	
	其实，C语言中只有一维数组
	
	
2，一维数组
	2.1 定义格式
		类型说明符	数组名[整型表达式] {={初始化列表}};
			{}: 可要可不要
		
		"类型说明符":指定数组元素的类型，任意C语言合法的类型都可以
		“数组名”：对象的名字，命名要符合C语言标识符的规定
		“整型表达式” ：指定数组中元素的个数，一般为常量表达式
		eg:
			#define N 3
			
		int a[10];//定义了一个数组，数组名a,里面有10个int型元素
		typeof(a)  =>一个具有10个int元素的数组类型 int[10]
		
		char b[10];
		typeof(b)  => 一个具有10个char元素的数组类型 char[10]
		
		
		int c;//在程序运行的时候，为c分配4个字节的空间
		
		在程序运行的时候，为a分配多大的空间？
		 10个int =》40个字节
		 
		sizeof(a) =>40
		
	2.2 一维数组在内存中的存放
		在连续的地址空间中，从低地址到高地址依次存放数组中的每个元素。
		意思：第二个元素只能紧跟着第一个元素后面存放
		
		int a[10];
		0x0001  -> 第一个元素
		0x0005  -> 第二个元素
		....
		
	2.3一维数组元素的引用
		int a[10];
		
		引用方式：
			数组名[下标];//C语言的下标是从0开始
			
				a[0] 数组中第一个元素
				...
				
				a[9]
				
		
		引用数组元素a[i] 和引用普通变量是一样的，都有左值和右值，还可以取地址
		eg:
			
			int  b;
			b = 1024;
			a[0] = 1024;//表示数组元素a[0]的地址
			b = a[0]; //表示数组元素a[0]的值
			
	练习：
		定义一个整型数组，数组中有10个元素。从键盘上输入值来给元素赋值
		然后把整个数组输出
		
		int a[10];
		
		for(i = 0; i<10;i++)
		{
			scanf("%d",&a[i]);
		}
		
		printf("%d\n",a);
		
	2.4 一维数组的初始化
		初值是存在一对花括号中
		
	(1)数组元素全部初始化
		int a[10] = {1,2,3,4,5,6,7,8,9,10};
		
	eg:
		int a[10];
		a[10] = {1,2,3,4,5,6,7,8,9,10};//error
		
	(2)可以只对部分元素初始化，后面的元素自动初始化为0
	
		int a[10] = {1,2,3};
		
		把整个数组初始化为0
		int a[10] = {0};
	
	(3)如果对全部元素初始化，那么在定义数组的时候，可以不指定数组的长度
			why?
		int a[] = {1,2,3};
		
		
	☆☆
		char s[] = {'a','b','c'};
			=>数组s里面有3个元素
			
		printf("%s",s);
		
		char s1[10] = {'a','b','c'};
		printf("%s",s1);
		
		“字符串长度” ：就是从一个起始地址的内容开始找，找到第一个\0为止
			前面有多少个字符，那就是字符串的长度
		
		数组的长度 ：数组有多少个元素	

		eg:
			int a[10];
				sizeof(a)/sizeof(a[0])
		
		字符数组的大小：这个数组所占空间的大小
		sizeof(s)	=>	3
		
		sizeof(s1) => 10
		
		
练习：	
	（1）求一个一维数组（int）中元素之和，最大值，最小值 3.c
	"遍历" ：对某个对象中每个元素访问且仅访问一次
	
		int x,i,max,min,sum;
		scanf("%d",&x);
		int a[x];
		max = a[0];
		min = a[0];
		for(i = 0;i <x;i++)
		{
			scanf("%d",&a[i]);
		}
		
		for(i = 0; i < x;i++)
		{
			if(max < a[i])
			{
				max = a[i];
			}
			if(min > a[i])
			{
				min = a[i];
			}
		}
		printf("max = %d,min = %d\n",max,min);
		
	（2）Fibonacci(斐波那契数列前20项之和)
		1 1 2 3 5 8 13 21 ...
		
		从第三项开始，每一项都是前面两项之和
		int Fi[20] = {1,1};
		int sum = 2;
		
		Fi[2] = Fi[1] +Fi[0];
		sum += Fi[2];
		
		Fi[3] = Fi[2] +Fi[1];
		sum += Fi[3];
		...
		for(i = 2;i < 20;i++)
		{
			Fi[i] = Fi[i-1] +Fi[i-2];
			sum += Fi[i];
		}
		
		
		
	（3）给定一个一维数组（int），判断是否为递增数组
	递增数组:
		a[0] < a[1] <a[2] <a[3]...a[n-1]
		
		int x,i;
		scanf("%d",&x);
		int a[x];
		int flag = 1;//递增标志位 1 ：递增 ,0 ：非递增
		for(i = 0;i <x;i++)
		{
			scanf("%d",&a[i]);
		}
		
		for(i = 0;i < x-1;i++)
		{
			if(a[i] >= a[i+1] )
			{
				flag = 0;
				break;
			}
		}
		/*
		if(i == x-1)
		{
			printf("yes\n");
		}
		*/
		if(flag)
		{
			printf("yes\n");
		}

		(4)在一个给定的升序的一维数组中，查找一个元素
		int a[10];
		
		查找数组a中是否有元素x，有就打印yes,没有就打印no
		
		二分法/二分查找法
		
		a:1 2 3 5 6 8 9    x = 4
		
		l = 0
		r = 6
		mid = 3
		
		=>
		l = 0
		r = mid-1 = 2
		mid = 1
		
		=>l = mid+1 = 2
		  r = 2
		  mid = 2
		  
		 =>l = mid+1 = 3
			r = 2
		
		int a[n];
		int l = 0,r = n-1;
		
		while(l <= r)
		{
			mid = (l+r)/2;//范围[l,r]中间元素的下标
			
			if(a[mid] == x)
			{
				break;
			}
			else if(a[mid] > x)
			{
				r = mid-1;
			}
			else
			{
				l = mid+1;
			}
		}
		
		
作业：
	因式分解
		90 = 2*3*3*5
		15
	算法1：
		sum=1;
		num1 = num;
		for(i=2；i<num；)
		{
			if(num%i==0)
			{
				sum*=i;
				a[x]=i;
				x++;
				num/=i;
			}
			else 
				i++;
			if(sum==num1)
				break;
		}
	
	算法2：
		90
		[2,n/2]
		
		for(i = 2;i <= n/2;i++)
		{
			while(n%i == 0)
			{
				printf("%d*",i);
				n /= i;
			}
		}
		printf("%d\n",n);
		90
	
	（1）将一个一维数组（int）排序
		冒泡排序：
			两两比较，大的往后移
			
			9 7 8 4 2
			7 9 8 4 2
			7 8 9 4 2
			7 8 4 9 2
			7 8 4 2 9
			
			if(a[0] > a[1])
			{
				a[0] <-> a[1]
			}
			if(a[1] > a[2])
			{
				a[1] <-> a[2]
			}
			...
			if(a[i] > a[i+1])
			{
				a[i] <-> a[i+1]
			}
			
			for(i = 0;i < N-1;i++)
			{
				if(a[i] > a[i+1])
				{
					a[i] <-> a[i+1]
				}
			}//一趟冒泡
			
			for(j = 0;j < N;j++)
			{
				for(i = 0;i < N-j;i++)
				{
					if(a[i] > a[i+1])
					{
						a[i] <-> a[i+1]
					}
				}
			}
			
		选择排序：
			从待排序的数组中，选择最大的那个元素与最后面的那个元素进行交换
			
			4 8 2 6 3
			
			i = 0;
			if(a[1] < a[0])
			{
				a[1] <-> a[0]
			}
			
			if(a[2] < a[0])
			{
				a[1] <-> a[0]
			}
			if(a[N-1] < a[0])
			{
				a[1] <-> a[0]
			}
			====
			for(i = 0;i < N;i++)
			{
				for(j = i+1;j < N;j++)
				{
					if(a[j] < a[i])
					{
						a[1] <-> a[0]
					}
				}
			}
			
	===========
	
	（2）一个一维数组中有正有负，写一个程序，把数组中负数放在正数的前面
			-3 4 9 -2 -3
			=>
			int next = 0;
			for(i = 0;i < N;i++)
			{
				if(a[i] < 0)
				{
					a[next] <->a[i]
					
					next++;
				}
			}
			
	
	（3）求一个一维数组中第二大的元素
		
			考虑有重复的元素
			
			9 9 8 8 8
			
			max = a[0];
			second = [1];
			
			for(i =0;i < M;i++)
			{
				if(a[i] > max)
				{
					second = max;
					max = a[i];
				}
			}
			
		
			
	（4）一维数组的插入排序
	
		int a[10];
		int l,r,mid;
		
		for(i = 0;i < 10;i++)
		{
			scanf("%d",&a[i]);
			
			//排序
			//找插入位置
				//二分法/二分查找法
				l = 0;
				r = i;
				while(l <= r)
				{
					mid = (l+r)/2;
					if(a[mid] == a[i])
					{
						break;
					}
					else if(a[mid] < a[i])
					{
						l = mid+1;
					}
					else
					{
						r = mid-1;
					}
				}
					
				//插入操作
				//把插入位置及后面的元素，每一个都往后移
				x = a[i];
				//mid,...i-1
				for(j = i-1;j >= mid;j--)
				{
					a[j+1] = a[j];
				}
				a[mid] = x;
			
		}
		
==========================
	
		
	