回顾：
	一维数组
	定义：
	
	数据元素的类型 数组名[数组元素个数];
	
	
	int a[4];
	
	数组a中有4个元素 a[0] a[1] a[2] a[3] ,每个元素int 型
	
	typeof(a) =>int[4]
	
	
	=>假如我们要定义3个像a这种类型的对象
	
	对象 =》数组
	
	
	typeof(a) b[3];
	
	=>b数组名，它里面有3个元素，分别是b[0],b[1],b[2]
		并且这三个元素都是typeof(a)
		
	typeof(a) =>int[4]	
	
	int[4] b[3];
	
	b[0]   _ _ _ _
	b[1]   _ _ _ _
	b[2]   _ _ _ _
	
	
	每个元素代表着一个一维数组，且每个里面有4个int

	int[4] b[3]; //关键字不能与[]在一块
	
	int b[3][4];
	
		二维数组实际上是一个一维数组，只不过该一维数组中的元素又是一个一维数组
		
1.二维数组
	1.1二维数组的实质
		是一个一维数组
		
	1.2 二维数组的定义
		类型说明符 数组名[常量表达式（行大小）][常量表达式（列大小）];
		
	1.3 二维数组在内存中的存放
		int a[3][4]; 
		
		sizeof(a) => 3*4*4
		
		按行存放，即先存放第一行的元素，在放第二行的元素
		
	1.4 二维数组的引用
		
			数组名[行下标][列下标]
				
				下标：从0开始
		
	1.5 二维数组的初始化
		(1)分行给二维数组赋初值
			int b[3][4];
			typeof(b) =>int[4][3]
			int b[3][4] = {
						{1,2,3,4},//b[0]
						{2,3,4,5},//b[1]
						{3,4,5,6}//b[2]
					};	
					
		(2)将所有数据写在一个花括号内，按数组排列顺序对各元素赋初值
			int b[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12};
			
		(3)对部分元素赋初值，其余元素自动置0
			int b[3][4] = {{1},{2,3},{4,5}};
			
			or
			
			int b[3][4] = {1,2,3,4};
			
		(4)如果对全部元素赋初值，则定义数组时对第一维的长度省略，但第二维的长度不可以
		
			int [][4] = {1,2,3,4,5,6,7,8};	
			
		
2.字符数组
	元素都是字符形式
	
	字符串的结束标志 '\0'

	char s[] = {'a','b','c','\0'};
	
	%s ：格式符 输出字符串
		 遇到第一个\0结束
		 
	printf("%s\n",s);
	
	
	字符串的操作函数：
		strlen :求字符串的长度，
				遇到第一个\0结束
			strlen("gvjh") =>4
		
		strcmp :字符串的比较函数
				
				strcmp(s1 ,s2)
					s1 > s2 return 1
					s1 == s2  return 0
					s < s2   return -1
					
		strcat :字符串连接函数
				s1 : "1234"
				s2 : "asdf"
			
				strcat(s1,s2);
					 =>1234asdf
					 
		strcpy :字符串拷贝
			s1 : "1234"
			s2 : "asdf"
			
				strcpy(s1,s2);
					 =>asdf
					 
练习：
	（1）定义一个整型二维数组，从键盘上给各个元素赋值
		在把整个数组输出
		
	（2）求一个二维数组的最大值，最小值，及所有元素的和
	
		
	（3）求一个二维数组中列元素之和最大的那个列
		int a[3][4]
		
		(1)构造一个一维数组b[4],用来保存目标二维数组每一列的元素之和
			int b[4] = {0};
			
			b[0] += a[0][0]
			
			for(i = 0;i < 4;i++)//列下标
			{
				for(j = 0;j < 3;j++)//行下标
				{
					b[i] += a[j][i]
				}
				
			}
			
			int max = b[0];
			int i_max ;
			for(i = 0;i < 4;i++)
			{
				if(max < b[i])
				{
					max = b[i];
					i_max = i;
				}
			}
			
			
			
		
	
	（4）求一个二维数组山顶元素的个数，打印出山顶元素是哪个及其它的位置 
	
		判断a[i][j]是否为山顶元素，实际上就是判断比上，下，左，右都大
		
		1 2 3 5 
		4 5 2 4
		1 2 3 5
		2 5 6 3
		
			上 ：不存在 ,存在 （比它大）
			下 ：不存在 ,存在 （比它大）
			左 ：不存在 ,存在 （比它大）
			右 ：不存在 ,存在 （比它大）
			
			if(上：：不存在 ,存在 （比它大）&&下 ：不存在 ,存在 （比它大） && 左 ：不存在 ,存在 （比它大）
					&& 右 ：不存在 ,存在 （比它大）)
			{
				
			}
			
			=》
			int a[4][4]
			
			if((i==0 || a[i][j] > a[i-1][j]) &&
				(i == 3 || a[i][j]>a[i+1][j]) &&
				(j==0 || a[i][j] > a[i][j-1]) &&
				(j == 3 || a[i][j] > a[i][j+1]))
			{
				printf("a[%d][%d] = %d\n",i,j,a[i][j]);
			}
			
	(5)打印杨辉三角前10行
		1
		1 1
		1 2 1
		1 3 3 1
		1 4 6 4 1 
		1 5 10 10 5 1
	

作业：
	1.高数巨占座位
	a[6][6];
	n = 3
	
	0 0 0 1 1 0    1
	0 0 0 1 1 0    1
	0 1 0 1 0 1   
	0 0 0 0 0 0    4
	0 1 1 0 1 0    
	0 1 0 1 0 0   
	
	int count = 0;//表示一行连续 0个数
	int s = 0;//总的占座位的方式
	
	for(i = 0;i < 6;i++)
	{
		count = 0;
		for(j = 0;j < 6;j++)
		{
			if(a[i][j] == 0)
			{
				count++;//连续为0的个数加1
				if(count >= 3)
				{
					s++;
				}
			}
			else
			{
				count = 0;
			}
		}
	}
	printf("s = %d\n",s);
	求有多少种方式
		
	2.求一个一维数组最大子数组之和
		子数组：在一个数组中下标连续的n个元素(n>0),称为原数组的子数组
		
		2 -1 3
		
		2  =>2
		2 -1 => 1
		2 -1 3  =>4
		-1 =>-1
		-1 3  =>2
		3  =>3
		
	算法1：
		所有的子数组
			a1  所有开头的子数组
				a1 
				a1+a2
				a1+a2+a3
		
			j = 0;
			sum = a[0];
			j = 1;
			sum = a[0] +a[1]
			j = 2;
			sum = a[0]+a[1]+a[2]
			
		max = a[0];
		sum = a[0];
		for(j = 1;j < N;j++)
		{
			sum += a[j];
			if(sum > max)
			{
				max = sum;
			}
			
		}
		
		=>
		max = a[0];
		for(i = 0;i < N;i++)//以i开头的子数组
		{
			sum = a[i];
			
			for(j = i+1;j < N;j++)
			{
				sum += a[j];
				if(sum > max)
				{
					max = sum;
				}
				
			}
		}
		
		
	算法2：
		+ - + - - + +
			sum = 0;
			max = a[0];
			
			for(i = 0;i < N;i++)
			{
				sum += a[i];
				if(max < sum)
				{
					max = sum;
				}
				
				if(sum < 0)
					sum = 0;
			}
	
		
	3.数组部分和
		int a[N];
		
		K
		
		能不能从数组a中，任意选M个元素（M > 0,M <= N）,使得这M个元素和为K，元素不要求连续
		
		a:2 5 6 3 1 -1 -2 2
		
		
		M = 3 (自己输)
		K = 6 (自己输)
		
		2 5 6 3 1 -1 -2 2
		
		对于数组中的任意一个元素a[i] ，只有两种情况
		选中 1
		不选  0
		
	0	0 0 0 0 0 0 0 0   不选任意一个数组元素
	1	0 0 0 0 0 0 0 1    选中a[0]
	2	0 0 0 0 0 0 1 0    选中a[1]
	3	0 0 0 0 0 0 1 1    选中a[0] a[1]
		
		0 0 0 0 0 1 1 1
		.....
2^n-1	1 1 1 1 1 1 1 1
		
	(2^n -1)
		
		0 ~2^n-1
		
	x [0~2^n-1]
	
	for(x = 0; x <=(1<<n)-1;x++)
	{
		for(j = 0;j < n;j++)
		{
			if(x & (1 << j))
			{
				//x的第jbit为1
				sum += a[j];
			}
		}
		
		if(sum == k)
		{
			
		}
	}
	
	
		