管道
	能不能直接利用文件系统中的API函数
	
	利用文件系统的API，但是我的内容又不在文件系统上（硬盘上）
				=》内容在内核里面
				
				
=》pipe 
	无名管道。它在文件系统中没有名字，它的内容在内核中
	并且它的访问方式通过文件系统中的（read/write）
	
	不能用open
	
	所以在创建pipe时候，就必须返回它的文件描述符
	
	pipe在创建时，是在内核中开辟了一块缓冲区，同时返回两个文件描述符（一个用来读
	一个用来写）
		（1）pipe有两端，一个用来读，一个用来写
		（2）按顺序读写
		（3）内容读走了，就没有了
		（4）不支持lseek
		（5）pipe 随内核的持续性
		

===========
函数接口：
	pipe
	
	NAME
       pipe- create pipe

SYNOPSIS
       #include <unistd.h>

		pipe用来在内核中开辟一块空间（创建一个无名管道）
		创建后直接打开，并且返回两个文件描述符
       int pipe(int pipefd[2]);
		pipefd：数组，用来存放文件描述符
			pipefd[0] =>读
			pipefd[1] =>写
			
		返回值：成功返回0
				失败返回-1，同时errno被设置
				
	pipe本身是一个全双工，但是两个进程用一个管道实现全双工通信，必须以某种方式去让他们同步
	，不然的话就很有可能读到自己写的数据。所以一般在项目中，会做成两个或多个管道，一个用于读，一个用于写
	人为的把管道当做半双工
	
	
	pipe（无名管道）是不是任意两个进程都可以用来通信
	
	不可以
	是不是只能是父子进程进行通信？ 不尽然
	
	无名管道只能用于亲缘关系（两个进程的共同祖先来创建的无名管道）的进程
	
	
	为什么无名管道有一个这样的限制？
		没有名字，在文件系统中没有路径名
		只能通过继承来获取文件描述符从而进行通信
		
==============
	FIFO有名管道
	
	FIFO在pipe的基础上，给FIFO在文件系统中取了一个名字（在文件系统中有一个inode）
	
	FIFO在文件系统中有名字（随文件系统的持续性）但是他的内容在内核中（随内核的持续性）
	
DESCRIPTION
	FIFO和pipe类似，除了它在文件系统中有一个名字，他可以被多个进程打开或读写。当进程用FIFO去交换数据时候
	内核根本就没有把数据写到文件系统中，而是保存在内核的内部，因此FIFO在文件系统中没有内容，他把在文件系统中
	的文件名当作是一个入口，提供一个文件名，给其他的进程去open
	
	
	在数据交换前，FIFO的两端（read，write）必须都被打开
	通常情况下，打开FIFO的一端，一直阻塞到另外一端被打开
	
	一个进程也可以以“非阻塞”的方式（O_NONBLOCK）去打开
		在这个情况（非阻塞”），只读打开总会成功，即便是写端没有被打开
		只写打开总会失败，并且errno == EENXIO ,除非在读端已经打开才会成功
		

函数接口：		
	mkfifo ：创建一个有名管道
	
	NAME
       mkfifo - make a FIFO special file (a named pipe)

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>

       int mkfifo(const char *pathname, mode_t mode);
		pathname：要创建的有名管道在文件系统中的文件名（带路径）
		mode：
			创建的FIFO的权限，有两种方式指定
			（1）宏
				S_IWUSR
				S_IRUSR
			（2）八进制
				0666
				
				
	返回值：成功返回0
			失败返回-1，同时errno被设置
	
		
